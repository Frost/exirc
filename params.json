{"name":"Exirc","tagline":"IRC client adapter for Elixir projects","body":"# ExIrc\r\n\r\nExIrc is a IRC client library for Elixir projects. It aims to have a clear, well\r\ndocumented API, with the minimal amount of code necessary to allow you to connect and\r\ncommunicate with IRC servers effectively. It aims to implement the full RFC2812 protocol,\r\nand relevant parts of RFC1459.\r\n\r\n## Why?\r\n\r\nI had need of this in another project of mine, and found that there were no good libraries available, \r\ndocumentation was always missing, it wasn't clear how to use, and in general were not easy to work\r\nwith.\r\n\r\n## Status\r\n\r\n[![wercker status](https://app.wercker.com/status/236e4911da7c4575c49b1b20b9ec775d/m/ \"wercker status\")](https://app.wercker.com/project/bykey/236e4911da7c4575c49b1b20b9ec775d)\r\n\r\nAlpha. The API is complete and everything is implemented, but little testing has been done (I've tested the API against my own local IRC server, but nothing robust enough to call this production ready). Any bugs you find, please report them in the issue tracker and I'll address them as soon as possible. If you have any questions, or if the documentation seems incomplete, let me know and I'll fill it in.\r\n\r\n## Getting Started\r\n\r\nIf you use expm, the ExIrc package is available\r\n[here](http://expm.co/exirc).\r\n\r\nAdd ExIrc as a dependency to your project in mix.exs, and add it as an application:\r\n\r\n```elixir\r\n  defp deps do\r\n    [{:exirc, github: \"bitwalker/exirc\"}]\r\n  end\r\n\r\n  defp application do\r\n    [applications: [:exirc],\r\n     ...]\r\n  end\r\n```\r\n\r\nThen fetch it using `mix deps.get`.\r\n\r\nTo use ExIrc, you need to start a new client process, and add event handlers. An example event handler module\r\nis located in `lib/exirc/example_handler.ex`. **The example handler is kept up to date with all events you can\r\nexpect to receive from the client**. A simple module is defined below as an example of how you might\r\nuse ExIrc in practice. ExampleHandler here is the one that comes bundled with ExIrc.\r\n\r\n```elixir\r\ndefmodule ExampleSupervisor do\r\n    defrecord State, \r\n        host: \"chat.freenode.net\",\r\n        port: 6667,\r\n        pass: \"\",\r\n        nick: \"bitwalker\",\r\n        user: \"bitwalker\",\r\n        name: \"Paul Schoenfelder\",\r\n        client: nil,\r\n        handlers: []\r\n\r\n    def start_link(_) do\r\n        :gen_server.start_link(__MODULE__, [State.new()])\r\n    end\r\n\r\n    def init(state) do\r\n        # Start the client and handler processes, the ExIrc supervisor is automatically started when your app runs\r\n        {:ok, client}  = ExIrc.start_client!()\r\n        {:ok, handler} = ExampleHandler.start_link(nil)\r\n\r\n        # Register the event handler with ExIrc\r\n        ExIrc.Client.add_handler client, handler\r\n\r\n        # Connect and logon to a server, join a channel and send a simple message\r\n        ExIrc.Client.connect!   client, state.host, state.port\r\n        ExIrc.Client.logon      client, state.pass, state.nick, state.user, state.name\r\n        ExIrc.Client.join       client, \"#elixir-lang\"\r\n        ExIrc.Client.msg        client, :privmsg, \"#elixir-lang\", \"Hello world!\"\r\n\r\n        {:ok, state.client(client).handlers([handler])}\r\n    end\r\n\r\n    def terminate(_, state) do\r\n        # Quit the channel and close the underlying client connection when the process is terminating\r\n        ExIrc.Client.quit state.client, \"Goodbye, cruel world.\"\r\n        ExIrc.Client.stop! state.client\r\n        :ok\r\n    end\r\nend\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}